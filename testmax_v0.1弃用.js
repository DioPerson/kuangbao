import{connect}from'cloudflare:sockets';
const[d,e,U,C,P,S,A]=[new TextDecoder(),new TextEncoder(),[],{},new Map(),new Set(),new ArrayBuffer(8192)];
let W,T,B=new Uint8Array(A),O=0;
const g=(k,f,n)=>{const v=import.meta?.env?.[k]??n?.[k];return!v?f:typeof v!=='string'?v:(t=>t==='true'||t!=='false'&&(t[0]==='\n'?t.split('\n').map(x=>x.trim()).filter(Boolean):+t||t))(v.trim())};
const init=n=>{if(C.done)return C;[['I','ID','123456'],['U','UUID','5aba5b77-48eb-4ae2-b60d-5bfee7ac169e'],['P','IP',['104.16.160.145']],['T','TXT',[]],['R','PROXYIP','sjc.o00o.ooo:443'],['F','启用反代功能',!0],['N','NAT64',!1],['N2','我的节点名字','狂暴']].forEach(([k,k2,d])=>C[k]=g(k2,d,n));const u=C.U.replace(/-/g,'');for(let i=0;i<32;i+=2)U[i>>1]=parseInt(u.substr(i,2),16);return C.done=1,C};
const chk=a=>{for(let i=0;i<16;i++)if(a[i+1]!==U[i])return!1;return!0};
const tryConn=async(h,p,c,init)=>{const k=h+':'+p;if(P.has(k)&&!S.has(k))return{...P.get(k),initialData:init};try{const s=await connect({hostname:h,port:p});await s.opened;const r={tcpSocket:s,initialData:init};P.set(k,r);S.delete(k);return r}catch{S.add(k)}if(c.N&&/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(h))try{return await tryConn('2001:67c:2960:6464::'+h.split('.').map(x=>(+x).toString(16).padStart(2,'0')).join('').match(/.{4}/g).join(':'),p,{...c,N:0},init)}catch{}if(c.F&&c.R){const[h2,p2]=c.R.split(':');return await tryConn(h2,+p2||p,{...c,F:0},init)}throw Error('连接失败')};
const parseV=async(buf,c)=>{const a=new Uint8Array(buf),t=a[17],p=(a[18+t+1]<<8)|a[18+t+2];let o=18+t+4,h='';const at=a[o-1];if(at===1){h=a[o]+'.'+a[o+1]+'.'+a[o+2]+'.'+a[o+3];o+=4}else if(at===2){const l=a[o];h=d.decode(a.subarray(o+1,o+1+l));o+=l+1}else if(at===3){h=Array.from({length:8},(_,i)=>((a[o+2*i]<<8)|a[o+2*i+1]).toString(16)).join(':');o+=16}return await tryConn(h,p,c,buf.slice(o))};
const tunnel=(ws,tcp,init)=>{const w=tcp.writable.getWriter(),r=tcp.readable.getReader(),cleanup=()=>{try{r.releaseLock();w.releaseLock();tcp.close()}catch{}};ws.send(new Uint8Array([0,0]));init&&w.write(init);let b=[],t,len=0;ws.onmessage=({data})=>{const chunk=data instanceof ArrayBuffer?new Uint8Array(data):typeof data==='string'?e.encode(data):data;b.push(chunk);len+=chunk.length;t||(t=setTimeout(()=>{if(!len)return;if(b.length===1)w.write(b[0]);else{if(len<=8192){O=0;for(const x of b){B.set(x,O);O+=x.length}w.write(B.subarray(0,len))}else{const o=new Uint8Array(len);let pos=0;for(const x of b){o.set(x,pos);pos+=x.length}w.write(o)}}b=[];len=0;t=null},0))};(async()=>{try{for(;;){const{value,done}=await r.read();if(done)break;ws.send(value)}}catch{}finally{ws.close()}})();ws.onclose=cleanup};
const conf=(h,c)=>W||(W=c.P.concat([h+':443']).map(x=>{const[raw,name=c.N2]=x.split('#'),[addr,port=443]=raw.split(':');return`vless://${c.U}@${addr}:${port}?encryption=none&security=tls&type=ws&host=${h}&sni=${h}&path=%2F%3Fed%3D2560#${name}`}).join('\n'));
export default{async fetch(req,env){const c=init(env);if(req.headers.get('Upgrade')==='websocket'){try{const proto=req.headers.get('sec-websocket-protocol');if(!proto)return new Response('Missing protocol',{status:400});const data=Uint8Array.from(atob(proto.replace(/-/g,'+').replace(/_/g,'/')),c=>c.charCodeAt(0));if(!chk(data))return new Response('无效UUID',{status:403});const{tcpSocket,initialData}=await parseV(data.buffer,c),[client,server]=new WebSocketPair();server.accept();tunnel(server,tcpSocket,initialData);return new Response(null,{status:101,webSocket:client})}catch(e){return new Response('连接失败: '+e.message,{status:502})}}T||(T=req.headers.get('Host'));const p=new URL(req.url).pathname;return p===`/${c.I}`?new Response(`订阅地址: https://${T}/${c.I}/vless`):p===`/${c.I}/vless`?new Response(conf(T,c)):new Response('Hello Worker!')}};
